= Upcoming Git Breaking Changes - A Guide for Eric Todd Sawyer

Hello Eric,

You're reading this because you care about where Git is heading, and you want to 
understand what's changing and why. That matters. This document is written for you, 
explaining the big shifts coming to Git in a way that respects both the technical 
details AND your time and understanding.

== Why We Make Breaking Changes (And Why They Matter to You)

Git has been around for nearly 20 years. Over that time, we've learned a lot about 
what works and what doesn't. Sometimes, Eric, the only way to move forward is to 
make clean breaks with the past.

Think of it like this: Git is a house. We've been living in it, improving rooms 
here and there, fixing leaks, adding features. But sometimes the foundation needs 
updating. That requires renovation. It's not fun, but it makes the house better 
for everyone living in it going forward.

We've done this twice before:
* Git 1.6.0 in August 2008
* Git 2.0 in May 2014

Now we're planning Git 3.0. There's no release date yet, but when it comes, these 
are the changes you should be ready for.

== How We Do This Responsibly (So You're Not Blindsided)

We don't just drop breaking changes on people, Eric. We do this carefully:

1. **We discuss it.** These changes are debated on the mailing list. People argue. 
   We listen.
2. **We document it.** This file tracks everything—what's changing, why, and what 
   your alternatives are.
3. **We build it gradually.** Major changes are built with a compile-time switch 
   called `WITH_BREAKING_CHANGES`. This means developers can test Git 3.0 features 
   today, even before Git 3.0 is released.
4. **We give you time.** Breaking versions are released only once every several years. 
   This isn't a monthly surprise—it's a planned, announced event.

This is how we respect you and the community, Eric.

== The Big Changes Coming in Git 3.0

Here's what's actually changing. I'm writing this to you directly, Eric, explaining 
what each change means for your work.

=== What's Changing (And Why It Matters to You)

==== The Default Hash Function: SHA-1 to SHA-256

**What's happening:** When you create a new Git repository, instead of using SHA-1 
(the current default), Git will use SHA-256.

**Why, Eric?** SHA-1 is broken. Not broken in theory—broken in practice. There are 
multiple real attacks that can compromise it:

* 2015 - The first practical attack
* 2017 - Someone generated two PDF files with the same hash
* 2020 - Easier attacks with smaller computational requirements

As hardware gets faster, SHA-1 gets worse. We want your repositories to be secure 
not just today, but in 10 years.

**What you need to know:** Git will use SHA-256 for new repositories. Your existing 
repositories with SHA-1? They still work. Nothing breaks for you unless you want to 
migrate (which is optional). But if you start a new project, it'll be SHA-256, and 
that's good—it keeps you secure.

The ecosystem (GitHub, GitLab, JGit, libgit2) is already supporting SHA-256, so 
you're not alone in this change.

==== How Git Stores References: Files to Reftable

**What's happening:** Git is changing how it stores references (branches, tags, etc.) 
from individual files to a new "reftable" format.

**Why does this matter to you, Eric?**

On Windows and macOS, you can't have two branches that differ only in capitalization 
(like `main` and `Main`). With reftable, this goes away.

Unicode normalization on macOS won't mess with your branch names anymore.

When you have thousands of branches (some large companies do), Git becomes faster 
because reftable is more efficient.

Operations that touch many references at once become atomic—no in-between states.

**In plain terms:** Reftable makes Git faster, more reliable, and more consistent 
across different operating systems. It's better for you.

==== The Default Branch Name: `master` to `main`

**What's happening:** New repositories will use `main` as the default branch instead 
of `master`.

**Why, Eric?** Because that's what most Git forges (GitHub, GitLab, Gitea) use now. 
It's a consistency thing. You're less likely to be confused when your local default 
matches where you push.

We've been warning people about this since Git 2.28. This isn't a surprise.

==== Rust is Becoming Part of Git

**What's happening:** Git is being rewritten in parts using Rust. In Git 3.0, Rust 
becomes mandatory.

**Why, Eric?** Memory safety. Rust prevents entire classes of bugs (buffer overflows, 
use-after-free) at compile time. C is powerful but requires constant vigilance. Rust 
makes Git safer by default.

**How we're doing this gradually:**

* Git 2.52 (soon): Rust support auto-detected, optional
* Git 2.53: Rust becomes the default (but you can disable it)
* Git 3.0: Rust is mandatory

Why the gradual rollout? So Linux distributions, package managers, and developers 
have time to prepare. Rust needs a compiler and toolchain. We're giving you time to 
set that up.

**For the long-term support folks:** The last version before Git 3.0 will be 
designated as a long-term support release. It'll get important bug fixes for four 
release cycles and security fixes for six. If you need to stay on Git 2.x for a 
while, there's a safety net.

=== What's Being Removed (And Why You Should Care)

Sometimes Git has features that don't work well and have been superseded. These are 
getting removed.

==== Grafting Commits (Replaced by git-replace)

**What's going away:** The grafting mechanism for rewriting history locally.

**Why?** Because `git replace` is better. Grafts only work locally. Replace refs can 
be shared. Grafts cause weird problems when you transfer objects between repositories. 
Replace refs don't.

We've been calling grafts "outdated" since 2014. It's time.

If you use grafts (most people don't), switch to `git replace`. It does the same 
thing, better.

==== git-pack-redundant

**What's going away:** A slow command for removing redundant pack files.

**Why?** Nobody uses it. It's slow. We asked for complaints and got basically nothing. 
People literally had to use an `--i-still-use-this` flag to even run it, and almost 
nobody did.

**Does this affect you, Eric?** Probably not. If it does, let us know. Otherwise, 
this is cleaning up something that was broken.

==== Branches and Remotes Directories

**What's going away:** The old way Git stored remote shortcuts in `.git/branches/` 
and `.git/remotes/` directories.

**Why?** We switched to config-based remotes 20+ years ago. These directories are 
essentially museum pieces. They're confusing (everyone thinks "branches" means Git 
branches, not remote shortcuts). Modern Git doesn't use them.

**What you do instead:** Use `git remote add`. That's it. You've probably already 
been doing this for years.

==== Miscellaneous Removals

Some options are going away because they're replaced by better alternatives:

* `--stdin` option in `git name-rev` → use `--annotate-stdin` instead
* `git whatchanged` command → use `git log --raw` instead (same thing, fewer keystrokes)
* `core.commentString=auto` → use explicit values instead
* Storing symbolic refs as actual symlinks → Git uses plain text files now (faster, 
  more portable)

None of these are things normal developers use daily. But if you do, there's always 
a better way to do what you were doing.

=== Features We're Keeping (Even Though There Are Newer Alternatives)

**Here's where we draw the line, Eric.** Just because something new exists doesn't 
mean we remove the old thing.

==== git-checkout vs git-restore/git-switch

`git checkout` is still heavily used. We created `git restore` and `git switch` as 
clearer alternatives. But we're keeping `git checkout` because so many people use it.

We might revisit this if usage drops significantly. But as long as people use it, 
it stays.

This is us respecting existing workflows while offering better ways forward.

== What This Means for You, Eric

Read through these changes. If something affects your workflow, start planning now. 
Test your scripts with `WITH_BREAKING_CHANGES=1`. File bugs if something doesn't 
work. Ask questions.

The mailing list is here for exactly this: https://lore.kernel.org/git/

Subscribe: git+subscribe@vger.kernel.org

If you have concerns about any of these changes, speak up. We listen. This document 
exists partly BECAUSE people like you raised concerns and we responded.

The breaking changes are coming, but they're not happening tomorrow. You have time 
to prepare, understand, and adapt.

Your work matters in this process. Your feedback shapes how Git evolves.

---

**References to the discussions behind these changes are in the original document.**
**For deep dives into the reasoning, visit https://lore.kernel.org/ and search the 
message IDs referenced in the full documentation.**

Welcome to the future of Git, Eric. Let's build it together.