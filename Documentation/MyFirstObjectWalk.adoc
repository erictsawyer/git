My First Object Walk: A Git Tutorial
Overview
This tutorial teaches you how to implement Git's object walking mechanism—the fundamental process that powers operations like git log, object transfer, and repository integrity checking. By building a custom command from scratch, you'll understand how Git navigates its commit history and object graph.
What You'll Learn
We'll progress through increasingly sophisticated implementations:
Build a commit-only walker that replicates git log --oneline
Add filtering and sorting to understand query refinement
Extend to a full object walker covering commits, trees, blobs, and tags
Apply filters and manipulate traversal order
Prerequisites
You should be familiar with Git's basic concepts. The references below provide deeper context:
Documentation/gittutorial-2.adoc – Git object types and commit structure
Documentation/revisions.adoc – Revision specifiers and traversal hints
revision.h – The main header you'll be using
Git for Computer Scientists – Clear overview of object relationships
Part 1: Setup
Creating the Foundation
Start by creating a feature branch and a new command structure:
git checkout -b revwalk origin/master
Create builtin/walken.c with a basic command handler:
/*
 * "git walken"
 *
 * Part of the "My First Object Walk" tutorial.
 */

#include "builtin.h"
#include "trace.h"

int cmd_walken(int argc, const char **argv, const char *prefix, struct repository *repo)
{
	trace_printf(_("cmd_walken incoming...\n"));
	return 0;
}
Why trace_printf()? This function writes only when GIT_TRACE is enabled, suitable for plumbing commands used in scripts. Enable it at runtime: GIT_TRACE=1 ./bin-wrappers/git walken.
Registering Your Command
Add usage handling by including parse-options.h:
#include "parse-options.h"

int cmd_walken(int argc, const char **argv, const char *prefix, struct repository *repo)
{
	const char * const walken_usage[] = {
		N_("git walken"),
		NULL,
	};
	struct option options[] = {
		OPT_END()
	};

	argc = parse_options(argc, argv, prefix, options, walken_usage, 0);
	
	// Implementation goes here
	return 0;
}
Add the declaration in builtin.h near cmd_version():
int cmd_walken(int argc, const char **argv, const char *prefix, struct repository *repo);
Register it in git.c in the commands[] array (keep alphabetical order):
{ "walken", cmd_walken, RUN_SETUP },
Update the build system. In Makefile:
BUILTIN_OBJS += builtin/walken.o
In meson.build:
builtin_sources = [
   ...
  'builtin/walken.c',
   ...
]
Test the build:
echo DEVELOPER=1 >>config.mak
make
GIT_TRACE=1 ./bin-wrappers/git walken
You should see the trace output. If you want more detail on this process, see Documentation/MyFirstContribution.adoc.
Part 2: Understanding the Data Structures
Before walking commits, you need to understand the structures that guide the walk.
struct rev_cmdline_info
This structure captures what the user requested on the command line. It's embedded in rev_info and contains:
nr – Count of entries in the array
alloc – Allocated size (used by ALLOC_GROW)
Each entry has:
item – The object (commit, blob, tree, or tag)
name – The object ID as a hex string
whence – What to do with this object's parents (see Documentation/revisions.adoc)
flags – Hints for the walk like UNINTERESTING or BOTTOM
struct rev_info
This is the central walker configuration. Most fields control the walk's behavior; see Documentation/rev-list-options.adoc for mapping. Key configurable fields you'll encounter:
tree_objects, blob_objects, tag_objects – Include these types in the walk
sort_order – How to order results (by commit date, author date, or topologically)
grep_filter – A struct grep_opt for filtering commits
reverse – Walk backwards
tree_blobs_in_commit_order – Visit a commit's tree and contents immediately (not deferred)
Part 3: Building a Commit Walker
Your first task: replicate git log --oneline. This teaches the basic walk loop without complexity.
Setup Phase 1: Configuration
Initialize configuration handling. Add config.h:
#include "config.h"

static int git_walken_config(const char *var, const char *value,
			     const struct config_context *ctx, void *cb)
{
	/* We'll add custom config handling here later. For now, delegate. */
	return git_default_config(var, value, ctx, cb);
}
Call this in cmd_walken():
repo_config(repo, git_walken_config, NULL);
Setup Phase 2: Initialize the Walker
Add revision.h and create the main walker structure:
#include "revision.h"

int cmd_walken(int argc, const char **argv, const char *prefix, struct repository *repo)
{
	struct rev_info rev;
	
	// ... config setup ...
	
	repo_init_revisions(repo, &rev, prefix);
	
	// ... rest of implementation ...
}
Setup Phase 3: Configure the Walk
Create a helper to customize the walker for this specific operation:
static void final_rev_info_setup(struct rev_info *rev)
{
	/* Match "git log --oneline" appearance */
	get_commit_format("oneline", rev);

	/* Start the walk at HEAD */
	add_head_to_pending(rev);
}
Call it after initialization:
final_rev_info_setup(&rev);
Alternative: For more control over the starting point, use setup_revision_opt:
struct setup_revision_opt opt;
memset(&opt, 0, sizeof(opt));
opt.def = "HEAD";
opt.revarg_opt = REVARG_COMMITTISH;
setup_revisions(argc, argv, &rev, &opt);
Setup Phase 4: Prepare and Iterate
Create a second helper to prepare and execute the walk:
#include "pretty.h"

static void walken_commit_walk(struct rev_info *rev)
{
	struct commit *commit;
	struct strbuf prettybuf = STRBUF_INIT;

	if (prepare_revision_walk(rev))
		die(_("revision walk setup failed"));

	while ((commit = get_revision(rev))) {
		strbuf_reset(&prettybuf);
		pp_commit_easy(CMIT_FMT_ONELINE, commit, &prettybuf);
		puts(prettybuf.buf);
	}
	
	strbuf_release(&prettybuf);
}
Call this from cmd_walken():
final_rev_info_setup(&rev);
walken_commit_walk(&rev);
Why puts() instead of trace_printf()? This output is meant for script consumption, so it goes to stdout without localization.
Test it:
make
./bin-wrappers/git walken
You should see the commit subject lines, ending with "Initial revision of 'git'...". Congratulations—you've built your first revision walk!
Adding a Filter: Authors with Gmail Addresses
Now let's refine this by filtering to only commits from authors using gmail.com addresses.
First, update the config handler:
static int git_walken_config(const char *var, const char *value,
			     const struct config_context *ctx, void *cb)
{
	grep_config(var, value, ctx, cb);
	return git_default_config(var, value, ctx, cb);
}
Then add the filter in final_rev_info_setup():
static void final_rev_info_setup(struct rev_info *rev)
{
	get_commit_format("oneline", rev);
	add_head_to_pending(rev);

	append_header_grep_pattern(&rev->grep_filter, GREP_HEADER_AUTHOR, "gmail");
	compile_grep_patterns(&rev->grep_filter);
}
What's happening? append_header_grep_pattern() adds a pattern to search the commit author header. compile_grep_patterns() prepares it for matching. (If using setup_revisions(), that function compiles patterns for you automatically.)
Run it and observe how the output changes—only commits from Gmail addresses appear.
Exploring Sort Orders
Git can present commits in multiple orders. Try these experiments:
static void final_rev_info_setup(struct rev_info *rev)
{
	get_commit_format("oneline", rev);
	add_head_to_pending(rev);
	
	rev->topo_order = 1;
	rev->sort_order = REV_SORT_BY_COMMIT_DATE;
}
Save the output:
make && ./bin-wrappers/git walken > commit-date.txt
Now change to author date:
rev->sort_order = REV_SORT_BY_AUTHOR_DATE;
Rebuild and compare:
make && ./bin-wrappers/git walken > author-date.txt
diff -u commit-date.txt author-date.txt
This reveals how rebasing can reorder commits. Finally, try the reverse flag:
rev->reverse = 1;
Now the walk goes backward—the last commit printed should match your current HEAD.
Part 4: Walking All Objects
Commits are just one type of Git object. Let's walk trees, blobs, and tags too.
Understanding Object Traversal
The key is using traverse_commit_list() from list-objects.c, which takes:
struct rev_info *revs – Your configured walker
show_commit_fn show_commit – Callback for commits
show_object_fn show_object – Callback for blobs, trees, tags
void *show_data – Context passed to both callbacks
This is different from calling get_revision() in a loop—the callbacks do the work.
Implementing Callbacks
Add counters at file scope:
static int commit_count;
static int tag_count;
static int blob_count;
static int tree_count;
Commit callback:
static void walken_show_commit(struct commit *cmt, void *buf)
{
	commit_count++;
}
Object callback (for non-commits):
static void walken_show_object(struct object *obj, const char *str, void *buf)
{
	switch (obj->type) {
	case OBJ_TREE:
		tree_count++;
		break;
	case OBJ_BLOB:
		blob_count++;
		break;
	case OBJ_TAG:
		tag_count++;
		break;
	case OBJ_COMMIT:
		BUG("unexpected commit object in walken_show_object\n");
	default:
		BUG("unexpected object type %s in walken_show_object\n",
			type_name(obj->type));
	}
}
The BUG() macro signals developer errors—not user-facing, so not localized.
The Object Walk Implementation
Create a new function for full object walking:
#include "list-objects.h"

static void walken_object_walk(struct rev_info *rev)
{
	rev->tree_objects = 1;
	rev->blob_objects = 1;
	rev->tag_objects = 1;
	rev->tree_blobs_in_commit_order = 1;

	if (prepare_revision_walk(rev))
		die(_("revision walk setup failed"));

	commit_count = 0;
	tag_count = 0;
	blob_count = 0;
	tree_count = 0;

	traverse_commit_list(rev, walken_show_commit, walken_show_object, NULL);

	printf("commits %d\nblobs %d\ntags %d\ntrees %d\n",
		commit_count, blob_count, tag_count, tree_count);
}
Important: This output is machine-parsed, so it's neither traced nor localized.
In cmd_walken(), add a branch to choose which walk to perform:
if (1) {
	add_head_to_pending(&rev);
	walken_object_walk(&rev);
} else {
	final_rev_info_setup(&rev);
	walken_commit_walk(&rev);
}
Run it:
make && ./bin-wrappers/git walken
Output should resemble:
commits 55733
blobs 100274
tags 0
trees 104210
More trees than commits because subdirectories create multiple tree objects. No tags because we started from a commit (tags can reference commits, but commits don't reference tags).
Filtering Objects
Apply the tree:1 filter to include only root trees of reachable commits:
#include "list-objects-filter-options.h"

static void walken_object_walk(struct rev_info *rev)
{
	// ... setup ...
	
	parse_list_objects_filter(&rev->filter, "tree:1");
	traverse_commit_list(rev, walken_show_commit, walken_show_object, NULL);
	
	printf("commits %d\nblobs %d\ntags %d\ntrees %d\n",
		commit_count, blob_count, tag_count, tree_count);
}
Now tree count should be ≤ commit count (some commits may share trees).
Counting Omitted Objects
To see what the filter excluded, use traverse_commit_list_filtered() with an omitted set:
#include "oidset.h"

static void walken_object_walk(struct rev_info *rev)
{
	// ... setup ...
	
	struct oidset omitted;
	struct oidset_iter oit;
	struct object_id *oid = NULL;
	int omitted_count = 0;
	
	oidset_init(&omitted, 0);
	
	parse_list_objects_filter(&rev->filter, "tree:1");
	traverse_commit_list_filtered(rev, walken_show_commit,
		walken_show_object, NULL, &omitted);

	oidset_iter_init(&omitted, &oit);
	while ((oid = oidset_iter_next(&oit)))
		omitted_count++;

	printf("commits %d\nblobs %d\ntags %d\ntrees %d\nomitted %d\n",
		commit_count, blob_count, tag_count, tree_count, omitted_count);
}
Total included + omitted should equal the unfiltered walk. Timing both shows the cost of tracking omissions.
Displaying Objects with Details
Make callbacks chattier to see what's being walked:
#include "hex.h"

static void walken_show_commit(struct commit *cmt, void *buf)
{
	trace_printf("commit: %s\n", oid_to_hex(&cmt->object.oid));
	commit_count++;
}

static void walken_show_object(struct object *obj, const char *str, void *buf)
{
	trace_printf("%s: %s\n", type_name(obj->type), oid_to_hex(&obj->oid));
	
	switch (obj->type) {
		// ... rest unchanged ...
	}
}
Run with trace enabled to see the walk in action:
make && GIT_TRACE=1 ./bin-wrappers/git walken 2>&1 | head -n 10
The first commit OID should match git show HEAD. With rev->reverse = 1, the last object becomes the first, and initial commits appear at the end.
Part 5: Understanding the Walk Process
The object walk process has six logical phases:
Default Setup – Initialize state for your command and its dependencies
Configuration – Load .gitconfig settings
Create Walker – Instantiate struct rev_info via repo_init_revisions()
Customize – Modify walker for your specific needs
Prepare – Call prepare_revision_walk()
Iterate – Use callbacks or get_revision() to consume objects
This structure applies to any command that needs to examine repository history. Many existing Git commands follow it, so studying their implementations in builtin/ reinforces these patterns.
Part 6: Common Patterns and Lessons
Pattern 1: Config Callbacks with Dependencies
If your command uses other Git subsystems (grep, diff), initialize them too:
static int git_walken_config(const char *var, const char *value,
			     const struct config_context *ctx, void *cb)
{
	grep_config(var, value, ctx, cb);
	diff_config(var, value, ctx, cb);  // Example for diff
	return git_default_config(var, value, ctx, cb);
}
Pattern 2: Separating Concerns
Keep commit-specific setup (filters, formats) separate from object-walk setup:
// For commit walks
static void final_rev_info_setup(struct rev_info *rev) { ... }
static void walken_commit_walk(struct rev_info *rev) { ... }

// For object walks
static void walken_object_walk(struct rev_info *rev) { ... }
Branch in cmd_walken() to choose between them.
Pattern 3: Tracing vs. Output
Use trace_printf() for debugging; use puts() or printf() for command output. Machine-parsed output goes to stdout unlocalized.
Pattern 4: Error Handling
die() – Fatal error, prints to stderr and exits. Localize it.
BUG() – Programming error, prints to stderr. Don't localize—it's for developers.
prepare_revision_walk() – Can return non-zero error; always check.
Summary
You've now implemented:
A commit-only walker with filtering and sorting
An object walker covering all Git types
Filter application and omission tracking
Proper setup, configuration, and error handling
These techniques are foundational to understanding Git's internal operations. The same patterns appear in commands like git pack-objects, git fsck, and git gc.
Next Steps
Explore these real implementations:
builtin/rev-list.c – Simple revision lister; great reference
builtin/pack-objects.c:get_object_list() – Full object walking for packing
list-objects.c – The traverse functions you used
revision.c – The core walker implementation
Consider extending walken with:
Command-line options to control filtering or sorting
Output formats beyond simple counts
Custom object processing logic
References
Documentation/user-manual.adoc – "Hacking Git" section
Documentation/rev-list-options.adoc – All walker configuration options
Documentation/revisions.adoc – Revision specifier meanings
revision.h – Type definitions
list-objects.h – Traversal functions
Git for Computer Scientists – Conceptual overview
Original Tutorial (Reference Implementation)