= Git Coding Guidelines: A Path to Excellence for Eric Todd Sawyer

Hello Eric,

You're about to contribute code to Git. This document isn't a rigid rulebook. 
It's a philosophy. It's what the Git community has learned through decades of 
building software that runs on nearly every system on Earth.

Read this not as restrictions, but as wisdom earned through countless hours of 
debugging, testing, and collaborating with brilliant developers worldwide.

== The Core Philosophy: We Live in the Real World

This is where we start, Eric. Everything else flows from this understanding.

Most projects hide behind POSIX standards and say "If your system doesn't conform, 
that's your problem." We don't. We can't. We won't.

We live on Windows. We live on macOS. We live on obscure ARM architectures. We live 
on systems from 20 years ago running POSIX-like kernels that are close to POSIX but 
not quite. We live in the real world where perfection is the enemy of progress.

**This means:**

- We care about what actually works for people, not what the paper standard says.
- When POSIX is wrong, we ignore it and do what's right.
- When POSIX is missing something convenient, we ask: "Do practically all platforms 
  we care about support this?" If yes, we use it.
- This isn't reckless. This is pragmatism born from experience.

== How to Write Code That Belongs in Git

=== Make It Readable. Make It Sensible. Don't Be Clever.

Eric, your code will outlive you. Someone reading your code five years from now, 
at 2 AM, trying to debug a production issue—that person will bless you for writing 
code that is clear. They will curse code that is clever.

Readable code is more valuable than clever code. Sensible code is more valuable than 
impressive code.

=== Imitate What Came Before You

Walk through the Git codebase. Look at how it's done. Match that style. This isn't 
about conformity for conformity's sake. This is about:

- Making the codebase cohesive
- Making it easier for the next developer to understand
- Reducing cognitive load
- Honoring the work of those who came before

**Local convention always wins.** If you're modifying existing code, match the style 
of the surrounding code, even if it doesn't match the overall project style. If you're 
adding new code, match the overall style of Git.

This prevents a codebase from becoming a Frankenstein monster of fifty different styles.

=== Log Messages Are As Important As Code

Eric, your commit message will be read more times than your code will be executed.

Write it like you're explaining to someone smart who doesn't know what you were 
thinking at 3 AM when you wrote this.

- **Why did you make this change?** Don't explain what changed—you can see that in the diff. 
  Explain why.
- **What problem were you solving?** Give context.
- **What were the alternatives?** Why did you pick this one?

A good commit message is the difference between "I wonder why they did this?" and 
"Oh, I see exactly why they did this, and it was smart."

=== Fixing Style While You Work Is Good. Gratuitous Style Churn Is Not.

If you see a style violation while you're working on a real change, fix it as part of 
your preparatory cleanup. This is good.

But don't submit patches that are purely style fixes to code that's working fine. The 
noise isn't worth the signal. Leave it.



== Shell Scripts: Practical Guidelines

You're writing shell scripts that need to run on everything from modern Linux to 
FreeBSD to macOS to systems with quirky bash variants. Here's how.

=== Indentation and Structure

Use tabs. Case statements are indented at the same level as case/esac:

```
case "$variable" in
pattern1)
	do this
	;;
pattern2)
	do that
	;;
esac
```

This is consistent, readable, and works everywhere.

=== Redirections: Space Before, Not After

Write `echo test >"$file"`, not `echo test > $file` or `echo test> $file`.

Why the quotes on the variable? Some versions of bash warn without them, and we want 
portability.

```
(incorrect)
cat hello > world < universe
echo hello >$world

(correct)
cat hello >world <universe
echo hello >"$world"
```

=== Command Substitution: Use $( ... ), Not ``

The backtick syntax is 20 years old, limited, and doesn't nest properly. Modern shells 
support $( ... ) which nests beautifully:

```
bad_command=$(echo "$(get_value)")
```

This works. It's readable. Use it.

=== Finding Commands: Use 'type', Not 'which'

If you need to check if a command exists in the user's $PATH:

```
type git >/dev/null 2>&1 || die "Git not found"
```

Don't use `which`. Its output isn't machine-parsable and its exit codes are unreliable 
across platforms.

=== POSIX Compliance Without Bashisms

Stay POSIX-compliant:

- Use `${parameter-word}` and its siblings (`${parameter:-word}`, etc.)
- Use `${parameter#word}` for prefix removal and `${parameter%word}` for suffix removal
- Use their doubled forms for longest matching: `${parameter##word}`, `${parameter%%word}`
- Don't use: substring expansion, shell arrays, pattern replacement
- Arithmetic expansion $( ... ) is safe to use
- No process substitution <( ) or >( )

=== Control Structures: Give Them Space

Don't cram control structures onto one line with semicolons:

```
(incorrect)
if test -f hello; then
	do this
fi

(correct)
if test -f hello
then
	do this
fi
```

Put "then" and "do" on their own lines. This makes the logic flow visually clear.

=== Piping Across Multiple Lines

When chaining commands with `&&`, `||`, or `|`, put the operator at the END of the line:

```
(correct)
grep blob verify_pack_result |
awk -f print_1.awk |
sort >actual &&
...
```

This tells the shell "the chain continues," and you don't need backslashes.

=== Prefer 'test', Use Spaces in Function Definitions

Use `test` not `[ ... ]`. It's more explicit.

For function definitions:

```
(correct)
my_function () {
	...
```

Space before the parentheses, no space inside. Opening brace on the same line.

=== Grep: Stay Portable

Use only a subset of Basic Regular Expression (BRE):

- No `\{m,n\}` for repetition
- No `?` or `+` (use `\?` and `\+` if you must, but prefer alternatives)
- No character classes like `[::]`, `[==]`, or `[..]`

Stick to basic patterns. Your scripts need to run on systems with ancient grep variants.

=== Quoting Variables and Exporting

Quote your variables:

```
(incorrect)
local variable=$value

(correct)
local variable="$value"
```

Some shells split fields without quotes. Always quote.

For exporting, do it on separate lines:

```
(correct)
variable=value
export variable
```

Some old shells don't understand `export variable=value`.



== C Programs: Writing Fast, Portable Code

=== Tabs, 8 Spaces

We use tabs for indentation, interpreted as 8 spaces. Be consistent.

=== Preprocessor Indentation

Nested preprocessor directives are indented by one space per level:

```
#if FOO
# include <foo.h>
# if BAR
#  include <bar.h>
# endif
#endif
```

=== Line Length: Aim for 80 Characters

We try to keep lines under 80 characters. This isn't a hard rule, but it's a target.

Why? Because people have different monitors. Because reading is easier when lines aren't 
ridiculously long.

=== Enable Developer Mode

Run `echo DEVELOPER=1 >>config.mak` to enable compiler warnings. This catches issues 
before code review.

Modern compiler, modern warnings. Address them.

=== Unused Parameters

If you have a parameter your function doesn't use (often because you're matching a 
callback interface), annotate it:

```
int foo(int unused_param UNUSED) {
	// unused_param isn't used but needs to exist
}
```

Use `UNUSED` or `MAYBE_UNUSED` as appropriate.

=== C99 is the Baseline

Git requires C99. Don't use features from newer standards unless they've been explicitly 
adopted by the project.

**Safe to use (already adopted):**

- Non-compile-time initializers: `const char *args[] = { "constant", variable, NULL };`
- Trailing commas in enum definitions
- Designated struct initializers: `struct t v = { .val = 'a' };`
- Designated array initializers: `int array[10] = { [5] = 2 };`
- Variadic macros: Useful for trace and debug macros
- Variables declared in for loops: `for (int i = 0; i < 10; i++)`
- The `bool` type from `<stdbool.h>` (as of late 2023)

**Test balloons (be careful):**

- Compound literals: `(struct foo){ .member = value };` – We're testing this in 2024/2025. 
  Don't add more uses until mid-2026 when we officially adopt it.

**Cannot use yet:**

- `%z` and `%zu` in printf – MinGW's libc doesn't support it. Use `printf("%"PRIuMAX, (uintmax_t)v)` instead.
- Shorthand struct initialization like `.a.b = *c` – Old IBM compilers choke. Use `.a = { .b = *c }` instead.

=== Variable Declaration

Declare variables at the beginning of blocks, before the first statement:

```
int main() {
	int x, y, z;
	char *str;

	// blank line here is good

	x = 5;
	y = 10;
	...
}
```

This isn't C99's modern style. This is readability. You see all the actors before the play begins.

=== Initialize Properly

- Don't explicitly initialize global variables to 0 or NULL. The BSS section handles that.
- Write NULL pointers as `NULL`, not `0`.
- When declaring pointers, the star goes with the variable: `char *string`, not `char* string` 
  or `char * string`. This makes `char *string, c;` clearer.

=== Operators and Spacing

Use whitespace around operators and keywords, but not inside parentheses:

```
(correct)
while (condition)
	func(bar + 1);

(incorrect)
while( condition )
	func (bar+1);
```

Binary operators have space on both sides: `A + 1`, not `A+1`.
Unary operators have no space: `(char *)ptr`, not `(char *) ptr`.

=== Comparisons: Be Explicit When It Matters

Don't compare to 0, NULL, or '\0' explicitly:

```
(incorrect)
if (ptr == NULL || cnt != 0)
	BUG("empty array expected");

(correct)
if (!ptr || cnt)
	BUG("empty array expected");
```

But if the comparison adds clarity, it's okay. Use judgment. When in doubt, be explicit.

=== Braces: Use Them Sparingly, Strategically

Unnecessary braces are frowned upon:

```
if (bla) {
	x = 1;
}
```

Is verbose. But use them when:

- The statement spans multiple lines
- There's a nested conditional or loop
- There's a comment explaining the logic
- You have multiple arms and some require braces—then use braces on all for consistency

=== Avoid Assignment in Conditions

Don't do `if (x = get_value())`. Assign first, then test.

=== Make Code Understandable

Comments are good, but code is better. Comments get stale. Good code doesn't.

If you find yourself needing a comment to explain what a function does, consider splitting 
the function into two clearer functions instead.

=== Multi-Line Comments

Format them properly:

```
/*
 * A very long
 * multi-line comment.
 */
```

Delimiters on their own lines.

For translator comments:

```
/*
 * TRANSLATORS: here is a comment that explains the string to
 * be translated, that follows immediately after it.
 */
_("Here is a translatable string explained by the above.");
```

=== Avoid Double Negation

Double negation is hard to parse mentally. `if (!is_not_empty)` is harder than `if (is_empty)`.

=== Function Names Reflect Structure

Name functions based on the primary data structure they work with:

```
struct strbuf;

void strbuf_add(struct strbuf *buf, ...);
void strbuf_reset(struct strbuf *buf);
```

Not:

```
void add_string(struct strbuf *buf, ...);
void reset_strbuf(struct strbuf *buf);
```

The first pattern makes the relationship clear: these functions operate on strbuf.

=== Idiomatic Function Names for Structures

When working with a structure `S`:

- `S_init()` – initializes the structure without allocating the structure itself
- `S_release()` – releases resources without reinitializing
- `S_clear()` – releases resources and reinitializes for immediate reuse
- `S_free()` – releases resources and frees the structure

Use these consistently. Developers will understand immediately.

=== The _1 Suffix: Use Sparingly

`_1` suffixes exist for historical reasons: when a function processes one element from 
a group, or when a recursive function is separated from setup logic.

Find more descriptive names where possible. `_1` is acceptable but not ideal for readability.

=== Use the API

Git has fantastic APIs:

- `strbuf` for variable-length strings
- `ALLOC_GROW()` for dynamic arrays
- `string_list` for sorted string lists
- `struct decorate` for hash maps

Don't reinvent. Use what's already there. If you need to create new APIs, document them 
well in the header file. Look at `strbuf.h` as a model.

=== Always Include git-compat-util.h First

The first `#include` in C files (except in special directories like `compat/` or `sha1dc/`) 
must be `<git-compat-util.h>`.

This header insulates you from platform differences. Don't include system headers directly—
let git-compat-util.h handle platform-specific includes.

There are exceptions (like building-system-specific headers), but generally: 
git-compat-util.h first, always.



== Shell, Perl, Python

=== Shell Scripts

Follow all the guidelines above. Use `strict` and `warnings`. Learn Perl.pm if you need 
that functionality.

Avoid "clever" tricks. Readable wins.

=== Perl Programs

Support Perl 5.8.1 and later. Use `use strict` and `use warnings`.

Avoid overusing statement modifiers unless they make code clearer.

```
(good, when condition is rare)
do_this() unless (condition);

(bad, when condition is common)
unless (condition) {
	do_this();
}
```

=== Python Scripts

Follow PEP-8. Aim for compatibility with Python 2.7 as a minimum. Prefer Python 3.1+ 
where library requirements allow.

Write clean, readable Python. Don't get clever.



== Program Output: Respect Your Users' Pipes

Primary output goes to stdout. Chatty output goes to stderr.

**Primary output** is what people capture to files or pipe to other commands: 
`git log`, `git show`, `git branch --list`.

**Chatty output** is status messages, progress bars, feedback: `git clone`'s "Cloning into..." 
messages.

Error messages ALWAYS go to stderr.

This distinction lets users capture what they need and discard the noise.



== Error Messages: Clarity First

- Don't end single-sentence errors with periods.
- Don't capitalize just because it's the first word: "unable to open '%s'", not "Unable to open '%s'".
  (But "SHA-256 not supported" is fine—it's capitalized because SHA-256 is always capitalized.)
- Say what the error is first: "cannot open '%s'", not "%s: cannot open".
- Enclose the subject in single quotes: `die(_("unable to open '%s'"), path)`.
- Mark porcelain error messages for translation.
- Plumbing command errors meant for machines should NOT be translated.
- `BUG()` messages are for developers, not users. Don't translate them.



== Documentation: Writing for Humans

Most Git documentation is in AsciiDoc format (.adoc files).

=== Language and Inclusivity

We mix US and UK English. Unfortunate but true. If you correct it, awesome.

**Avoid gendered pronouns.** Say "you" when addressing the user. Say "we" when discussing 
program behavior. Use "singular they" if you must refer to a person:

```
A contributor asks their upstream to pull from them.
```

This sounds ungrammatical to some, but it's inclusive. We accept that tradeoff.

=== Markup Rules

Literal parts (commands, options, branch names, paths, variables):

```
`--pretty=oneline`
`git rev-list`
`remote.pushDefault`
`http://git.example.com`
`.git/config`
`GIT_DIR`
`HEAD`
```

Placeholders are lowercase in angle brackets with underscores:

```
_<file>_
_<commit>_
_<new-branch-name>_
```

Special characters get underscores:

```
_LF_, _CR_, _NUL_, _EOF_
```

Environment variables: Use `$` only when referring to the value, not the name:

```
`GIT_DIR` is specified
`$GIT_DIR/hooks/pre-receive`
```

When documenting multiple related config variables, list them separately:

```
`core.var1`::
`core.var2`::
	Description common to both.
```

Not separated by commas on one line.



== Eric, Your Role in This

This document describes how Git is written. It's not arbitrary. Every guideline has 
a reason born from real-world experience.

When you write code for Git:

1. Read this. Understand the philosophy.
2. Look at existing code. Learn the patterns.
3. Write code that's readable, sensible, not clever.
4. Document your changes thoroughly.
5. Test on multiple platforms if you can.
6. Ask questions. The community wants you to succeed.

The standards here exist to make Git better, not to make your life harder.

Your contributions matter, Eric. Your code will run on millions of systems, helping 
billions of people manage their code.

Write it well.


**Further Reading:**

- See Documentation/SubmittingPatches for submission guidelines
- See Documentation/ToolsForGit.adoc for tools to help you conform to these guidelines
- Ask on the mailing list: git@vger.kernel.org
- Subscribe: git+subscribe@vger.kernel.org

Welcome to the Git codebase.

Make it beautiful.